---
layout: post
title:  "数据结构基础()：链表"
categories: DataStructure  
tags:  C DataStructure
author: mio4
---

* content
{:toc}




## （一）链表基本操作
带有头结点的链表的基本操作：
```c 
#include <stdio.h>
#include <stdlib.h>

struct Node;
typedef int ElementType;
typedef struct Node *PtrToNode; 
typedef PtrToNode List;
typedef PtrToNode Position;

struct Node {
    ElementType Element;
    Position Next;
};

List MakeEmptyList(List L); //生成一个空链表
int IsEmpty(List L); //判断链表是否为空
int IsLast(Position P, List L); //是否是链表中的最后一个节点
int Length(List L); //返回链表长度
Position Find(ElementType X, List L); //查找元素在链表中的位置
void Delete(ElementType X, List L); //删除指定元素的节点
Position FindPrevious(ElementType X, List L); //查找指定元素的前节点
void InsertBefore(ElementType X, List L, Position P); //在P节点前插入节点
void InsertAfter(ElementType X, List L, Position P); //在P节点后插入节点
void DeleteList(List L); //删除链表
Position Header(List L); //返回头结点
Position First(List L); //返回第一个节点
Position Advance(Position P); //返回节点的后节点
void Print(List L); //打印链表

List MakeEmptyList(List L){
    if (L != NULL){
        DeleteList(L);
    }
    L = (List) malloc(sizeof(struct Node));
    if(L == NULL){
        printf("Out of space\n");
        exit(1);
    }
    L->Next = NULL;
    return L;
}

int IsEmpty(List L){
    return L->Next == NULL; 
}

int IsLast(Position P, List L){
    return P->Next == NULL;
}

int Length(List L){
    int length = 0;
    Position P = L->Next; 
    while(P->Next != NULL){
        length++;
        P = P->Next; 
    }
    return length;
}

Position Find(ElementType X,List L){
    Position P = L->Next;
    while(P!=NULL && P->Element != X){ 
        P = P->Next;
    }
    return P;
}

void Delete(ElementType X, List L){
    Position TmpNode;
    Position P = FindPrevious(X,L);
    if(!IsLast(P,L)){
        TmpNode = P->Next;
        P->Next = TmpNode->Next;
        free(TmpNode);
    }
}

Position FindPrevious(ElementType X, List L){ 
    Position P = L;
    while(P->Next != NULL && P->Next->Element != X){
        P = P->Next;
    }
    return P;
}

void InsertBefore(ElementType X, List L, Position P){
    Position AddNode = (Position)malloc(sizeof(struct Node));
    Position PreviousNode = L;
    
    if(AddNode == NULL){
        printf("Out of space\n");
        exit(1);
    }
    while(PreviousNode->Next != P){ 
        PreviousNode = PreviousNode->Next;
    }
    AddNode->Element = X;
    PreviousNode->Next = AddNode;
    AddNode->Next = P;
}

void InsertAfter(ElementType X, List L, Position P){
    Position AddNode = (Position)malloc(sizeof(struct Node));
    Position AfterNode = P->Next;

    if(AddNode == NULL){
        printf("Out of space\n");
        exit(1);
    }
    AddNode->Element = X;
    AddNode->Next = P->Next;
    P->Next = AddNode;
}

void DeleteList(List L){
    Position tmp;
    Position P = L->Next;
    L->Next = NULL;
    while(P != NULL){
        tmp = P->Next;
        free(P);
        P = tmp;
    }
}

Position Header(List L){
    return L;
}

Position First(List L){
    return L->Next;
}

Position Advance(Position P){
    return P->Next;
}

void Print(List L){
    Position P = L->Next;
    while(P!=NULL){
        printf("%d ",P->Element);
        P = P->Next;
    }
    printf("\n");
}

int main(void){ //测试函数
    int i;
    List L = NULL;
    printf("创建一个空链表\n");
    L = MakeEmptyList(L);
    
    Position P = L;
    for(i=0;i <= 5;i++){
        InsertAfter(i,L,P);
        P = Advance(P);
    }
    printf("链表的长度是 %d\n",Length(L));
    printf("打印链表中的所有元素:\n");
    Print(L);

    printf("删除链表中的前两个元素\n");
    for(i=0;i < 2;i++){
        Delete(i,L);
    }
    printf("链表的长度是 %d\n",Length(L));
    printf("打印链表中的所有元素:\n");
    Print(L);

    printf("删除链表\n");
    DeleteList(L);
    if(IsEmpty(L)){
        printf("L是一个空链表\n");
    }
    system("pause");
    return 0;
}
```
### 0x1 删除节点


### 0x2 插入节点


## （二）

## （三）

## （四）